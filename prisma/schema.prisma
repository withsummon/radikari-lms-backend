// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  output          = "../generated/prisma/client"
  previewFeatures = ["relationJoins"]
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Roles {
  ADMIN
  USER
}

enum UserType {
  INTERNAL
  GOOGLE
}

model User {
  id          String   @id @unique
  fullName    String
  email       String   @unique
  password    String
  phoneNumber String
  role        Roles    @default(USER)
  type        UserType @default(INTERNAL)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantUser           TenantUser[]
  knowledge            Knowledge[]
  knowledgeActivityLog KnowledgeActivityLog[]
  operation            Operation[]
  teamLeader           TenantUser[]           @relation("teamLeader")
  supervisor           TenantUser[]           @relation("supervisor")
  manager              TenantUser[]           @relation("manager")
  headOfOperation      TenantUser[]           @relation("headOfOperation")
  aiChatRooms          AiChatRoom[]
  userKnowledge        UserKnowledge[]
}

model Operation {
  id                    String   @id @unique
  name                  String
  description           String
  headOfOperationUserId String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  headOfOperationUser User     @relation(fields: [headOfOperationUserId], references: [id], onDelete: Cascade)
  tenant              Tenant[]
}

model Tenant {
  id          String   @id @unique
  name        String
  description String
  operationId String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  operation Operation @relation(fields: [operationId], references: [id], onDelete: Cascade)

  tenantRole    TenantRole[]
  tenantUser    TenantUser[]
  tenantSetting TenantSetting[]
  knowledge     Knowledge[]
  aiChatRooms   AiChatRoom[]
}

model TenantRole {
  id          String   @id @unique
  identifier  String
  level       Int
  name        String
  description String
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant     Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantUser TenantUser[]

  @@unique([tenantId, identifier])
}

model TenantUser {
  id                    String  @id @unique
  userId                String
  teamLeaderUserId      String?
  supervisorUserId      String?
  managerUserId         String?
  headOfOperationUserId String?
  tenantId              String
  tenantRoleId          String

  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenantRole      TenantRole @relation(fields: [tenantRoleId], references: [id], onDelete: Cascade)
  tenant          Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  teamLeader      User?      @relation(name: "teamLeader", fields: [teamLeaderUserId], references: [id], onDelete: Cascade)
  supervisor      User?      @relation(name: "supervisor", fields: [supervisorUserId], references: [id], onDelete: Cascade)
  manager         User?      @relation(name: "manager", fields: [managerUserId], references: [id], onDelete: Cascade)
  headOfOperation User?      @relation(name: "headOfOperation", fields: [headOfOperationUserId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
}

model TenantSetting {
  id       String @id @unique
  key      String
  value    String
  tenantId String

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, key])
}

model MasterKnowledgeCategory {
  id        String   @id @unique
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MasterKnowledgeCase {
  id        String   @id @unique
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum KnowledgeStatus {
  PENDING
  APPROVED
  REVISION
  REJECTED
}

enum KnowledgeAccess {
  PUBLIC
  TENANT
  EMAIL
}

enum KnowledgeType {
  ARTICLE
  CASE
}

model Knowledge {
  id              String          @id @unique
  tenantId        String?
  category        String
  subCategory     String
  case            String
  headline        String
  type            KnowledgeType
  access          KnowledgeAccess
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  status          KnowledgeStatus @default(PENDING)
  createdByUserId String

  tenant        Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByUser User    @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)

  knowledgeAttachment  KnowledgeAttachment[]
  knowledgeContent     KnowledgeContent[]
  knowledgeActivityLog KnowledgeActivityLog[]
  AiChatRoomMessage    AiChatRoomMessage[]
  userKnowledge        UserKnowledge[]

  @@index([tenantId, access])
  @@index([createdByUserId])
  @@index([access])
}

model UserKnowledge {
  id          String   @id @unique
  knowledgeId String
  userId      String
  createdAt   DateTime @default(now())

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([knowledgeId, userId])
}

model KnowledgeAttachment {
  id            String   @id @unique
  knowledgeId   String
  attachmentUrl String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
}

model KnowledgeContent {
  id          String @id @unique
  knowledgeId String
  title       String
  description String @db.Text
  order       Int

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)

  knowledgeContentAttachment KnowledgeContentAttachment[]

  @@unique([knowledgeId, order])
}

model KnowledgeContentAttachment {
  id                 String @id @unique
  knowledgeContentId String
  order              Int
  attachmentUrl      String

  knowledgeContent KnowledgeContent @relation(fields: [knowledgeContentId], references: [id], onDelete: Cascade)

  @@unique([knowledgeContentId, order])
}

enum KnowledgeActivityLogAction {
  CREATE
  APPROVE
  REJECT
  REVISION
}

model KnowledgeActivityLog {
  id              String                     @id @unique
  knowledgeId     String
  action          KnowledgeActivityLogAction
  createdByUserId String
  createdAt       DateTime                   @default(now())

  knowledge     Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
  createdByUser User      @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
}

model AiChatRoom {
  id        String   @id @unique
  tenantId  String
  userId    String
  title     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user     User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages AiChatRoomMessage[]
}

enum AiChatRoomMessageSender {
  USER
  SYSTEM
}

model AiChatRoomMessage {
  id                   String                  @id @unique
  aiChatRoomId         String
  sender               AiChatRoomMessageSender
  message              String
  htmlFormattedMessage String?
  knowledgeId          String?
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt

  aiChatRoom AiChatRoom @relation(fields: [aiChatRoomId], references: [id], onDelete: Cascade)
  knowledge  Knowledge? @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
}
