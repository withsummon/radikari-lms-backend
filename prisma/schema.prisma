// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  output          = "../generated/prisma/client"
  previewFeatures = ["relationJoins"]
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Roles {
  ADMIN
  USER
}

enum UserType {
  INTERNAL
  GOOGLE
}

model User {
  id                String    @id @unique
  fullName          String
  email             String    @unique
  password          String    @default("")
  phoneNumber       String
  role              Roles     @default(USER)
  type              UserType  @default(INTERNAL)
  profilePictureUrl String?   @db.Text
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?

  tenantUser                           TenantUser[]
  knowledge                            Knowledge[]
  knowledgeActivityLog                 KnowledgeActivityLog[]
  operation                            Operation[]
  teamLeader                           TenantUser[]                          @relation("teamLeader")
  supervisor                           TenantUser[]                          @relation("supervisor")
  manager                              TenantUser[]                          @relation("manager")
  headOfOperation                      TenantUser[]                          @relation("headOfOperation")
  aiChatRooms                          AiChatRoom[]
  userKnowledge                        UserKnowledge[]
  accessControlListCreator             AccessControlList[]                   @relation("AclCreator")
  accessControlListUpdater             AccessControlList[]                   @relation("AclUpdater")
  assignmentUserAccesses               AssignmentUserAccess[]
  assignmentUserAttempts               AssignmentUserAttempt[]
  assignments                          Assignment[]
  assignmentUserAttemptQuestionAnswers AssignmentUserAttemptQuestionAnswer[]
  announcements                        Announcement[]
  forums                               Forum[]
  forumComments                        ForumComment[]
  forumLikes                           ForumLike[]
  forumCommentLikes                    ForumCommentLike[]
  forumPinneds                         ForumPinned[]
  userActivityLogs                     UserActivityLog[]
  notifications                        Notification[]
  aiPromptCreator                      AiPrompt[]                            @relation("AiPromptCreator")
  aiPromptUpdater                      AiPrompt[]                            @relation("AiPromptUpdater")
  broadcastCreator                     Broadcast[]                           @relation("BroadcastCreator")
  broadcastUpdater                     Broadcast[]                           @relation("BroadcastUpdater")
}

model Operation {
  id                    String   @id @unique
  name                  String
  description           String
  headOfOperationUserId String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  headOfOperationUser User     @relation(fields: [headOfOperationUserId], references: [id], onDelete: Cascade)
  tenant              Tenant[]
}

model Tenant {
  id          String   @id @unique
  name        String
  description String
  operationId String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  operation Operation @relation(fields: [operationId], references: [id], onDelete: Cascade)

  tenantUser    TenantUser[]
  tenantSetting TenantSetting[]
  knowledge     Knowledge[]
  aiChatRooms   AiChatRoom[]
  announcements Announcement[]
  forums        Forum[]
  aiPrompt      AiPrompt?
  broadcast     Broadcast?
}

model TenantRole {
  id          String   @id @unique
  identifier  String
  level       Int
  name        String
  description String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantUser                     TenantUser[]
  accessControlList              AccessControlList[]
  assignmentTenantRoleAccesses   AssignmentTenantRoleAccess[]
  announcementTenantRoleAccesses AnnouncementTenantRoleAccess[]

  @@unique([identifier])
}

model TenantUser {
  id                    String  @id @unique
  userId                String
  teamLeaderUserId      String?
  supervisorUserId      String?
  managerUserId         String?
  headOfOperationUserId String?
  tenantId              String
  tenantRoleId          String

  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenantRole      TenantRole @relation(fields: [tenantRoleId], references: [id], onDelete: Cascade)
  tenant          Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  teamLeader      User?      @relation(name: "teamLeader", fields: [teamLeaderUserId], references: [id], onDelete: Cascade)
  supervisor      User?      @relation(name: "supervisor", fields: [supervisorUserId], references: [id], onDelete: Cascade)
  manager         User?      @relation(name: "manager", fields: [managerUserId], references: [id], onDelete: Cascade)
  headOfOperation User?      @relation(name: "headOfOperation", fields: [headOfOperationUserId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
}

model TenantSetting {
  id       String @id @unique
  key      String
  value    String
  tenantId String

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, key])
}

model MasterKnowledgeCategory {
  id        String   @id @unique
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MasterKnowledgeSubCategory {
  id        String   @id @unique
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MasterKnowledgeCase {
  id        String   @id @unique
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum KnowledgeStatus {
  PENDING
  APPROVED
  REVISION
  REJECTED
}

enum KnowledgeAccess {
  PUBLIC
  TENANT
  EMAIL
}

enum KnowledgeType {
  ARTICLE
  CASE
}

model Knowledge {
  id               String          @id @unique
  tenantId         String?
  category         String?
  subCategory      String?
  case             String?
  headline         String
  type             KnowledgeType
  access           KnowledgeAccess
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  status           KnowledgeStatus @default(PENDING)
  createdByUserId  String
  totalViews       Int             @default(0)
  isArchived       Boolean         @default(false)
  rejectionComment String?         @db.Text
  version          Int             @default(1)
  parentId         String?

  tenant        Tenant?     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByUser User        @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
  parent        Knowledge?  @relation(name: "parent", fields: [parentId], references: [id], onDelete: Cascade)
  children      Knowledge[] @relation("parent")

  knowledgeAttachment        KnowledgeAttachment[]
  knowledgeContent           KnowledgeContent[]
  knowledgeActivityLog       KnowledgeActivityLog[]
  AiChatRoomMessage          AiChatRoomMessage[]
  userKnowledge              UserKnowledge[]
  aiChatRoomMessageKnowledge AiChatRoomMessageKnowledge[]

  @@unique([parentId, version])
  @@index([tenantId, access])
  @@index([createdByUserId])
  @@index([access])
  @@index([totalViews])
  @@index([status])
  @@index([parentId])
  @@index([version, parentId])
}

model UserKnowledge {
  id          String   @id @unique
  knowledgeId String
  userId      String
  createdAt   DateTime @default(now())

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([knowledgeId, userId])
}

model KnowledgeAttachment {
  id            String   @id @unique
  knowledgeId   String
  attachmentUrl String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
}

model KnowledgeContent {
  id          String @id @unique
  knowledgeId String
  title       String
  description String @db.Text
  order       Int

  knowledge Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)

  knowledgeContentAttachment KnowledgeContentAttachment[]

  @@unique([knowledgeId, order])
}

model KnowledgeContentAttachment {
  id                 String @id @unique
  knowledgeContentId String
  order              Int
  attachmentUrl      String

  knowledgeContent KnowledgeContent @relation(fields: [knowledgeContentId], references: [id], onDelete: Cascade)

  @@unique([knowledgeContentId, order])
}

enum KnowledgeActivityLogAction {
  CREATE
  APPROVE
  REJECT
  REVISION
}

model KnowledgeActivityLog {
  id              String                     @id @unique
  knowledgeId     String
  action          KnowledgeActivityLogAction
  createdByUserId String
  createdAt       DateTime                   @default(now())

  knowledge     Knowledge @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
  createdByUser User      @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
}

model AiChatRoom {
  id         String   @id @unique
  tenantId   String
  userId     String
  title      String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isArchived Boolean  @default(false)

  tenant   Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user     User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages AiChatRoomMessage[]
}

enum AiChatRoomMessageSender {
  USER
  ASSISTANT
}

model AiChatRoomMessage {
  id                   String                  @id @unique
  aiChatRoomId         String
  sender               AiChatRoomMessageSender
  message              String
  htmlFormattedMessage String?
  knowledgeId          String?
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  promptTokens         Int?
  completionTokens     Int?
  totalTokens          Int?

  aiChatRoom                 AiChatRoom                   @relation(fields: [aiChatRoomId], references: [id], onDelete: Cascade)
  knowledge                  Knowledge?                   @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
  aiChatRoomMessageKnowledge AiChatRoomMessageKnowledge[]
}

model AiChatRoomMessageKnowledge {
  id                  String @id @unique
  aiChatRoomMessageId String
  knowledgeId         String

  aiChatRoomMessage AiChatRoomMessage @relation(fields: [aiChatRoomMessageId], references: [id], onDelete: Cascade)
  knowledge         Knowledge         @relation(fields: [knowledgeId], references: [id], onDelete: Cascade)
}

model AccessControlList {
  id           String   @id @unique
  featureName  String
  actionName   String
  tenantRoleId String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdById  String
  updatedById  String

  feature    AclFeature @relation(fields: [featureName], references: [name], onDelete: Cascade)
  tenantRole TenantRole @relation(fields: [tenantRoleId], references: [id], onDelete: Cascade)
  createdBy  User       @relation("AclCreator", fields: [createdById], references: [id], onDelete: Cascade)
  updatedBy  User       @relation("AclUpdater", fields: [updatedById], references: [id], onDelete: Cascade)

  @@unique([featureName, actionName, tenantRoleId])
}

model AclFeature {
  name        String   @unique
  isDeletable Boolean  @default(true)
  isEditable  Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  accessControlList AccessControlList[]
  action            AclAction[]
}

model AclAction {
  id          String   @id @unique
  name        String
  featureName String
  isDeletable Boolean  @default(true)
  isEditable  Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  feature AclFeature @relation(fields: [featureName], references: [name], onDelete: Cascade)

  @@unique([featureName, name])
}

enum AssignmentAccess {
  TENANT_ROLE
  USER
}

enum AssignmentStatus {
  DRAFT
  PUBLISHED
  EXPIRED
}

model Assignment {
  id                String           @id @unique
  title             String
  durationInMinutes Int
  status            AssignmentStatus @default(PUBLISHED)
  access            AssignmentAccess
  expiredDate       String
  tenantId          String
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  createdByUserId   String?
  createdByUser     User?            @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)

  assignmentTenantRoleAccesses AssignmentTenantRoleAccess[]
  assignmentUserAccesses       AssignmentUserAccess[]
  assignmentQuestions          AssignmentQuestion[]
  assignmentUserAttempts       AssignmentUserAttempt[]
}

model AssignmentTenantRoleAccess {
  id           String @id @unique
  assignmentId String
  tenantRoleId String

  assignment Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  tenantRole TenantRole @relation(fields: [tenantRoleId], references: [id], onDelete: Cascade)
}

model AssignmentUserAccess {
  id           String @id @unique
  assignmentId String
  userId       String

  assignment Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum AssignmentQuestionType {
  MULTIPLE_CHOICE
  ESSAY
  TRUE_FALSE
}

model AssignmentQuestion {
  id           String                 @id @unique
  assignmentId String
  content      String
  type         AssignmentQuestionType
  order        Int

  assignment                             Assignment                              @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  assignmentQuestionOptions              AssignmentQuestionOption[]
  assignmentQuestionEssayReferenceAnswer AssignmentQuestionEssayReferenceAnswer?
  assignmentQuestionTrueFalseAnswer      AssignmentQuestionTrueFalseAnswer?
  assignmentUserAttemptQuestionAnswers   AssignmentUserAttemptQuestionAnswer[]

  @@unique([assignmentId, order])
}

model AssignmentQuestionOption {
  id                   String  @id @unique
  assignmentQuestionId String
  content              String
  isCorrectAnswer      Boolean

  assignmentQuestion                   AssignmentQuestion                    @relation(fields: [assignmentQuestionId], references: [id], onDelete: Cascade)
  assignmentUserAttemptQuestionAnswers AssignmentUserAttemptQuestionAnswer[]
}

model AssignmentQuestionTrueFalseAnswer {
  id                   String  @id @unique
  assignmentQuestionId String  @unique
  correctAnswer        Boolean

  assignmentQuestion AssignmentQuestion @relation(fields: [assignmentQuestionId], references: [id], onDelete: Cascade)
}

model AssignmentQuestionEssayReferenceAnswer {
  id                   String @id @unique
  assignmentQuestionId String @unique
  content              String

  assignmentQuestion AssignmentQuestion @relation(fields: [assignmentQuestionId], references: [id], onDelete: Cascade)
}

model AssignmentUserAttempt {
  id              String    @id @unique
  userId          String
  assignmentId    String
  score           Int?
  percentageScore Float?
  isSubmitted     Boolean   @default(false)
  submittedAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user                                 User                                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignment                           Assignment                            @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  assignmentUserAttemptQuestionAnswers AssignmentUserAttemptQuestionAnswer[]

  @@unique([userId, assignmentId])
}

model AssignmentUserAttemptQuestionAnswer {
  id                         String                 @id @unique
  type                       AssignmentQuestionType
  assignmentUserAttemptId    String
  assignmentQuestionId       String
  assignmentQuestionOptionId String?
  essayAnswer                String?
  isAnswerCorrect            Boolean?
  graderComment              String?
  gradedByUserId             String?
  trueFalseAnswer            Boolean?

  assignmentUserAttempt    AssignmentUserAttempt     @relation(fields: [assignmentUserAttemptId], references: [id], onDelete: Cascade)
  assignmentQuestion       AssignmentQuestion        @relation(fields: [assignmentQuestionId], references: [id], onDelete: Cascade)
  assignmentQuestionOption AssignmentQuestionOption? @relation(fields: [assignmentQuestionOptionId], references: [id], onDelete: Cascade)
  gradedByUser             User?                     @relation(fields: [gradedByUserId], references: [id], onDelete: Cascade)

  @@unique([assignmentUserAttemptId, assignmentQuestionId])
}

model Announcement {
  id              String   @id @unique
  title           String
  content         String   @db.Text
  tenantId        String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdByUserId String?
  createdByUser   User?    @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  tenant                         Tenant                         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  announcementTenantRoleAccesses AnnouncementTenantRoleAccess[]
}

model AnnouncementTenantRoleAccess {
  id             String @id @unique
  announcementId String
  tenantRoleId   String

  announcement Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  tenantRole   TenantRole   @relation(fields: [tenantRoleId], references: [id], onDelete: Cascade)
}

model Forum {
  id              String   @id @unique
  tenantId        String
  title           String
  content         String   @db.Text
  createdByUserId String
  likesCount      Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByUser    User              @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
  forumComments    ForumComment[]
  forumAttachments ForumAttachment[]
  forumLikes       ForumLike[]
  forumPinneds     ForumPinned[]
}

model ForumAttachment {
  id            String @id @unique
  forumId       String
  attachmentUrl String @db.Text

  forum Forum @relation(fields: [forumId], references: [id], onDelete: Cascade)
}

model ForumComment {
  id               String   @id @unique
  forumId          String
  content          String   @db.Text
  likesCount       Int      @default(0)
  replyToCommentId String?
  createdByUserId  String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  createdByUser     User               @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
  replyToComment    ForumComment?      @relation(name: "ForumCommentReplies", fields: [replyToCommentId], references: [id], onDelete: Cascade)
  forum             Forum              @relation(fields: [forumId], references: [id], onDelete: Cascade)
  replies           ForumComment[]     @relation(name: "ForumCommentReplies")
  forumCommentLikes ForumCommentLike[]

  @@index([forumId])
  @@index([replyToCommentId])
  @@index([createdByUserId])
}

model ForumLike {
  id        String   @id @unique
  userId    String
  forumId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  forum Forum @relation(fields: [forumId], references: [id], onDelete: Cascade)

  @@unique([userId, forumId])
}

model ForumCommentLike {
  id             String @id @unique
  userId         String
  forumCommentId String

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  forumComment ForumComment @relation(fields: [forumCommentId], references: [id], onDelete: Cascade)

  @@unique([userId, forumCommentId])
}

model ForumPinned {
  id        String   @id @unique
  forumId   String
  userId    String
  createdAt DateTime @default(now())

  forum Forum @relation(fields: [forumId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([forumId, userId])
}

model UserActivityLog {
  id        String   @id @unique
  userId    String
  action    String   @db.Text
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum NotificationType {
  KNOWLEDGE_APPROVED
  ANNOUNCEMENT
  ASSIGNMENT
  FORUM
}

model Notification {
  id          String           @id @unique
  userId      String
  tenantId    String?
  type        NotificationType
  title       String
  message     String           @db.Text
  referenceId String?
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
}

model AiPrompt {
  id              String   @id @unique
  tenantId        String   @unique
  prompt          String   @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdByUserId String?
  updatedByUserId String?

  tenant        Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByUser User?  @relation("AiPromptCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)
  updatedByUser User?  @relation("AiPromptUpdater", fields: [updatedByUserId], references: [id], onDelete: Cascade)
}

model Broadcast {
  id              String   @id @unique
  tenantId        String   @unique
  content         String   @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdByUserId String?
  updatedByUserId String?

  tenant        Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdByUser User?  @relation(name: "BroadcastCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)
  updatedByUser User?  @relation(name: "BroadcastUpdater", fields: [updatedByUserId], references: [id], onDelete: Cascade)
}
